#include <iostream>
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <cstdlib>
#include <ctime>

using namespace std;

// -------------------------------------------
// Structy Vec2 i Particle
// -------------------------------------------
struct Vec2 {
    float x, y;
    Vec2(float x_=0, float y_=0) : x(x_), y(y_) {}
    Vec2 operator+(const Vec2& other) const { return Vec2(x + other.x, y + other.y); }
    Vec2 operator*(float scalar) const { return Vec2(x * scalar, y * scalar); }
};

struct Particle {
    Vec2 pos;
    Vec2 vel;
    bool dotknelaZiemi = false;
};

// -------------------------------------------
// Callback do zmiany rozmiaru okna
// -------------------------------------------
void zmiana_rozmiaru_okna(GLFWwindow* window, int width, int height)
{
    glViewport(0, 0, width, height);
}

// -------------------------------------------
// Program główny
// -------------------------------------------
int main()
{
    srand(time(nullptr));

    if (!glfwInit())
    {
        cout << "Failed to initialize GLFW" << endl;
        return -1;
    }

    glfwWindowHint(GLFW_SAMPLES, 16);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    GLFWwindow* window = glfwCreateWindow(800, 600, "Particles 2D", NULL, NULL);
    if (window == NULL)
    {
        cout << "Failed to open GLFW window" << endl;
        return -1;
    }
    glfwMakeContextCurrent(window);

    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        cout << "Failed to initialize GLAD" << endl;
        return -1;
    }

    glViewport(0, 0, 800, 600);
    glfwSetFramebufferSizeCallback(window, zmiana_rozmiaru_okna);

    // -------------------------------------------
    // Inicjalizacja cząstek
    // -------------------------------------------
    const int NUM_PARTICLES = 30;
    Particle particles[NUM_PARTICLES];

    for (int i = 0; i < NUM_PARTICLES; i++) {
        particles[i].pos = Vec2((rand() % 100 - 50) / 50.0f, (rand() % 100) / 50.0f + 0.5f);
        particles[i].vel = Vec2(0.0f, -0.01f);
    }

    // -------------------------------------------
    // VAO + VBO dla punktów
    // -------------------------------------------
    unsigned int VAO, VBO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);
    glBindVertexArray(VAO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, NUM_PARTICLES * 2 * sizeof(float), nullptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);

    glPointSize(10.0f);

    Vec2 gravity(0.0f, -0.0005f);
    const float EPSILON = 0.00001f;

    // -------------------------------------------
    // Pętla renderująca
    // -------------------------------------------
    while (!glfwWindowShouldClose(window))
    {
        // Aktualizacja pozycji cząstek
        for (int i = 0; i < NUM_PARTICLES; i++) {
            particles[i].pos = particles[i].pos + particles[i].vel + gravity;

            // odbicie od podłogi
            if (particles[i].pos.y < -1.0f) {
                particles[i].pos.y = -1.0f;

                if (abs(particles[i].vel.y) < EPSILON)
                    particles[i].vel.y = 0.0f;
                else
                    particles[i].vel.y *= -0.6f;

                particles[i].dotknelaZiemi = true;
            }
        }

        // Wypełnienie VBO
        float points[NUM_PARTICLES * 2];
        for (int i = 0; i < NUM_PARTICLES; i++) {
            points[i * 2 + 0] = particles[i].pos.x;
            points[i * 2 + 1] = particles[i].pos.y;
        }

        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferSubData(GL_ARRAY_BUFFER, 0, NUM_PARTICLES * 2 * sizeof(float), points);
        glBindBuffer(GL_ARRAY_BUFFER, 0);

        // Render
        glClearColor(0.0235f, 0.2039f, 0.4863f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        glBindVertexArray(VAO);
        glDrawArrays(GL_POINTS, 0, NUM_PARTICLES);
        glBindVertexArray(0);

        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glfwTerminate();
    return 0;
}